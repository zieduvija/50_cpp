# 50 C++ uzdevumi 50/50
## Nodaļas
<details>
<summary>Burti</summary>
<br>
  
## Burti 1 - 'a' skaits vārdā

### Definīcija
> Uzdevums sameklēt burtu 'a' skaitu dotajā vārdā.

### Ievaddatu raksturojums
> Ievaddatu vienīgajā rindā dots vārds. Vārda maksimālais burtu skaits ir 100.

### Izvaddatu raksturojums
> Izvaddatu vienīgajā rindā jāizvada viens skaitlis, kas norāda cik reižu šajā vārdā ir atkārtojies burts 'a'?

## Paraugdati
#### **Stdin**
<pre><code>abra</code></pre>
#### **Stdout**
<pre><code>2</code></pre>

### Mans rezultāts
> 5/5 punkti
### Links uz kodu
https://github.com/zieduvija/50_cpp/blob/master/code/burti1.cpp
### Links uz uzdevumu
https://clevercode.lv/task/show/burti1
  


## Burti 2 - vārds no pirmajiem burtiem

### Definīcija
> Izdrukāt vārdu, kas veidojas no citu vārdu pirmajiem burtiem.

### Ievaddatu raksturojums
> Katrā no ievaddatu piecām rindām dots viens vārds.

### Izvaddatu raksturojums
> Izvaddatu vienīgajā rindā ir vārds, kas sastāv no piecu doto vārdu pirmajiem burtiem.

## Paraugdati
#### **Stdin**
<pre><code>sile<br>
abra<br>
upe<br>
lietus<br>
ezers</code></pre>
#### **Stdout**
<pre><code>saule</code></pre>

### Mans rezultāts
> 5/5 punkti
### Links uz kodu
https://github.com/zieduvija/50_cpp/blob/master/code/burti2.cpp
### Links uz uzdevumu
https://clevercode.lv/task/show/burti2


## Burti 3 - pēdejais burts vārdā

### Definīcija
> Atrast vārda pēdējo burtu.

### Ievaddatu raksturojums
> Ievaddatu vienīgajā rindā dots vārds.

### Izvaddatu raksturojums
> Izvaddatu vienīgajā rindā ir dotā vārda pēdējais burts.

## Paraugdati
#### **Stdin**
<pre><code>bulta</code></pre>
#### **Stdout**
<pre><code>a</code></pre>

### Mans rezultāts
> 5/5 punkti
### Links uz kodu
https://github.com/zieduvija/50_cpp/blob/master/code/burti3.cpp
### Links uz uzdevumu
https://clevercode.lv/task/show/burti3


## Burti 4 - dotā burta skaits vārdā

### Definīcija
> Atrast cik reižu dotais burts atkārtojas dotajā vārdā.

### Ievaddatu raksturojums
> Ievaddatu pirmajā rindā ir dots vārds, kura garums nepārsniedz 20 simbolus, bet otrajā rindā burts.

### Izvaddatu raksturojums
> Izvaddatu vienīgajā rindā ir skaitlis, kas norāda cik reižu dotais burts atkārtojas dotajā vārdā.

## Paraugdati
#### **Stdin**
<pre><code>abra<br>
a</code></pre>
#### **Stdout**
<pre><code>2</code></pre>

### Mans rezultāts
> 5/5 punkti
### Links uz kodu
https://github.com/zieduvija/50_cpp/blob/master/code/burti4.cpp
### Links uz uzdevumu
https://clevercode.lv/task/show/burti4




## Burti 5 - kurš burts primais?

### Definīcija
> Atrast cik reižu dotais burts atkārtojas dotajā vārdā.

### Ievaddatu raksturojums
> Dots vārds, kura garums nepārsniedz 20 burtus un 2 burti. Atrast un izvadīt to burtu no diviem dotajiem, kurš, lasot doto vārdu, parādās pirmais. Zināms, ka katrs no burtiem vārdā sastopams tieši vienu reizi.

### Izvaddatu raksturojums
> Izvaddatu vienīgajā rindā ir atrastais burts.

## Paraugdati
#### **Stdin**
<pre><code>pasaka<br>
k<br>
s</code></pre>
#### **Stdout**
<pre><code>s</code></pre>

### Mans rezultāts
> 5/5 punkti
### Links uz kodu
https://github.com/zieduvija/50_cpp/blob/master/code/burti5.cpp
### Links uz uzdevumu
https://clevercode.lv/task/show/burti5




## Burti 6 - vārda veidošana

### Definīcija
> Doti 2 vārdi, kuru garums nepārsniedz 20 burtus. Pārbaudīt vai no pirmā vārda burtiem var izveidot otro vārdu. Zināms, ka otrais vārds ir īsāks par pirmo un tajā neviens burts neatkārtojas. Atbildes ir **Var** un  **Nevar**.

### Ievaddatu raksturojums
> Ievaddatu pirmajās divās rindās doti 2 vārdi.


### Izvaddatu raksturojums
> Izvaddatu vienīgajā rindā ir vārds **Var** vai **Nevar**.

## Paraugdati
#### **Stdin**
<pre><code>saule<br>
sula</code></pre>
#### **Stdout**
<pre><code>Var</code></pre>

### Mans rezultāts
> 5/5 punkti
### Links uz kodu
https://github.com/zieduvija/50_cpp/blob/master/code/burti6.cpp
### Links uz uzdevumu
https://clevercode.lv/task/show/burti6


## Burti 7 - aizstāj burtu

### Definīcija
> Dots vārds un 2 burti. Uzdevums sameklēt dotajā vārdā visus burtus, kas vienādi ar pirmo doto burtu un aizstāt tos ar otro doto burtu.

### Ievaddatu raksturojums
> Ievaddatu pirmajā rindā dots vārds, bet otrajā un trešajā rindā viens burts.


### Izvaddatu raksturojums
> Izvaddatu vienīgajā rindā jāizvada vārds pēc pārveidošanas..

## Paraugdati
#### **Stdin**
<pre><code>lapa<br>
a<br>
u</code></pre>
#### **Stdout**
<pre><code>lupu</code></pre>

### Mans rezultāts
> 5/5 punkti
### Links uz kodu
https://github.com/zieduvija/50_cpp/blob/master/code/burti7.cpp
### Links uz uzdevumu
https://clevercode.lv/task/show/burti7

</details>

<details>
<summary>Pentamino</summary>
<br>

## Pentamino 1

### Definīcija
> Pentamino figūras veido no pieciem kvadrātiem, novietojot tos tā, ka katram kvadrātam ir kopīga mala ar kādu citu.
Šoreiz izmantosim tikai trīs veida pentamino figūras:<br>

![pentam1-1](https://user-images.githubusercontent.com/118617121/225156685-6de7d0d5-4b1c-46dc-8df9-a4774fe15c92.gif)
<br>

> Sauksim tās par A, B un C veida figūrām. Katra veida figūrai viens kvadrāts ir iekrāsots citādi. Sauksim to par attiecīgā veida figūras galveno kvadrātu.<br>
Kvadrātveida rūtiņu laukumā, kura izmēri ir 8*8, izvietosim ne vairāk kā 10 iepriekšminētā veida figūras tā, lai katras figūras kvadrāti sakristu ar laukuma rūtiņām, un katra no figūrām pilnībā ietilptu laukumā. Figūras drīkst pārklāties. Figūras nedrīkst būt pagrieztas vai apgrieztas. Laukuma kolonnas ir sanumurētas no kreisās puses uz labo ar naturāliem skaitļiem no 1 līdz 8 pēc kārtas. Analoģiski no lejas uz augšu ir sanumurētas arī rindas.<br>
**Jūsu uzdevums ir uzrakstīt programmu, kas nosaka, cik no 64 laukuma rūtiņām noklāj vismaz viena pentamino figūra.**


### Ievaddatu raksturojums
> Izvaddatu pirmā rinda satur naturālu skaitli N, 1 <= N <= 10, kas apzīmē uz laukuma izvietoto pentamino figūru skaitu. Katrā no nākošajām N faila rindām tiek dotas kādas figūras apraksts formā

<pre><code> burts kolonnas_numurs rindas_numurs </code></pre>
> , kur burts norāda attiecīgās figūras veidu (A,B vai C), bet kolonnas un rindas numurs norāda laukuma rūtiņu, kuru noklāj šīs figūras galvenais kvadrāts. Starp burtu un kolonnas numuru, kā arī starp kolonnas numuru un rindas numuru ir viens tukšumsimbols.



### Izvaddatu raksturojums
> Ievaddatu vienīgajā rindā jāizvada viens naturāls skaitlis - laukuma rūtiņu skaits, ko noklāj dotās pentamino figūras.

## Piezīmes
Pirmā testpiemēra zīmējums:<br>
![pentam1-2](https://user-images.githubusercontent.com/118617121/225157153-14a8561f-2bbf-4307-8939-6511a0556cf2.gif)


## Paraugdati
#### **Stdin**
<pre><code>5<br>
A 2 5<br>
C 5 7<br>
B 7 6<br>
C 8 1<br>
A 4 3</code></pre>
#### **Stdout**
<pre><code>22</code></pre>

### Mans rezultāts
> 12/12 punkti
### Links uz kodu
https://github.com/zieduvija/50_cpp/blob/master/code/pentamino_1.cpp
### Links uz uzdevumu
https://clevercode.lv/task/show/pentam1





## Pentamino 2

### Definīcija
> Pentamino figūras veido no pieciem kvadrātiem, novietojot tos tā, ka katram kvadrātam ir kopīga mala ar kādu citu.
Šoreiz izmantosim tikai pieca veida pentamino figūras:<br>

![pentam2-1](https://user-images.githubusercontent.com/118617121/225158132-320bf7ab-b225-4d26-83c1-15d6d9051b10.gif)


> Sauksim tās par A, B, C, D un E veida figūrām. Katra veida figūrai viens kvadrāts ir iekrāsots citādi. Sauksim to par attiecīgā veida figūras galveno kvadrātu. <br>
Kvadrātveida rūtiņu laukumā, kura izmēri ir K*K rūtiņas, izvietosim ne vairāk kā 100 iepriekšminētā veida figūras tā, lai katras figūras kvadrāti sakristu ar laukuma rūtiņām, un katra no figūrām pilnībā ietilptu laukumā. Figūras drīkst pārklāties. Figūras nedrīkst būt pagrieztas vai apgrieztas. Laukuma kolonnas ir sanumurētas no kreisās puses uz labo ar naturāliem skaitļiem no 1 līdz K pēc kārtas. Analoģiski no lejas uz augšu ir sanumurētas arī rindas.<br>
**Jūsu uzdevums ir uzrakstīt programmu, kas nosaka, cik no laukuma rūtiņām noklāj vismaz viena pentamino figūra.**


### Ievaddatu raksturojums
> Ievaddatu pirmā rinda satur naturālu skaitli K, 1 <= K <= 100, kas apzīmē laukuma malas garumu.
Faila otrā rinda satur naturālu skaitli N, 1 <= N <= 100, kas apzīmē uz laukuma izvietoto pentamino figūru skaitu.
Katrā no nākošajām N faila rindām tiek dotas kādas figūras apraksts formā

<pre><code> burts kolonnas_numurs rindas_numurs </code></pre>
> , kur burts norāda attiecīgās figūras veidu (A,B,C,D vai E), bet kolonnas un rindas numurs norāda laukuma rūtiņu, kuru noklāj šīs figūras galvenais kvadrāts. Starp burtu un kolonnas numuru, kā arī starp kolonnas numuru un rindas numuru ir viens tukšumsimbols.



### Izvaddatu raksturojums
> Izvaddatu vienīgajā rindā jāizvada viens naturāls skaitlis - laukuma rūtiņu skaits, ko noklāj dotās pentamino figūras.

## Piezīmes
Pirmā testpiemēra zīmējums:<br>

![pentam2-2](https://user-images.githubusercontent.com/118617121/225158435-bc92464c-5bfd-4182-8594-2d5ad0681c63.gif)



## Paraugdati
#### **Stdin**
<pre><code>8<br>
5<br>
A 2 5<br>
D 5 7<br>
B 7 6<br>
D 8 1<br>
E 4 6</code></pre>
#### **Stdout**
<pre><code>23</code></pre>

### Mans rezultāts
> 21/21 punkti
### Links uz kodu
https://github.com/zieduvija/50_cpp/blob/master/code/pentamino_2.cpp
### Links uz uzdevumu
https://clevercode.lv/task/show/pentam2






## Pentamino 3

### Definīcija
> Pentamino figūras veido no pieciem kvadrātiem, novietojot tos tā, ka katram kvadrātam ir kopīga mala ar kādu citu.
Šoreiz izmantosim tikai pieca veida pentamino figūras:<br>

![pentam2-1](https://user-images.githubusercontent.com/118617121/225158132-320bf7ab-b225-4d26-83c1-15d6d9051b10.gif)


> Sauksim tās par A, B, C, D un E veida figūrām. Katra veida figūrai viens kvadrāts ir iekrāsots citādi. Sauksim to par attiecīgā veida figūras galveno kvadrātu. <br>
Kvadrātveida rūtiņu laukumā, kura izmēri ir K*K rūtiņas, izvietosim ne vairāk kā 100 iepriekšminētā veida figūras tā, lai katras figūras kvadrāti sakristu ar laukuma rūtiņām, un katra no figūrām pilnībā ietilptu laukumā. Figūras drīkst pārklāties. Figūras nedrīkst būt pagrieztas vai apgrieztas. Laukuma kolonnas ir sanumurētas no kreisās puses uz labo ar naturāliem skaitļiem no 1 līdz K pēc kārtas. Analoģiski no lejas uz augšu ir sanumurētas arī rindas.<br>
**Mēs vēlamies jau daļēji aizpildītajā laukumā novietot vēl vienu figūru tā, lai tā nepārklātos ar iepriekš noliktajām.<br>Jūsu uzdevums ir uzrakstīt programmu, kas nosaka, cik dažādās laukuma vietās šo figūru var novietot.**


### Ievaddatu raksturojums
> Ievaddatu pirmā rinda satur naturālu skaitli K, 1 <= K <= 100, kas apzīmē laukuma malas garumu.
Faila otrā rinda satur naturālu skaitli N, 1 <= N <= 100, kas apzīmē uz laukuma izvietoto pentamino figūru skaitu.
Katrā no nākošajām N faila rindām tiek dotas kādas figūras apraksts formā

<pre><code> burts kolonnas_numurs rindas_numurs </code></pre>
> , kur burts norāda attiecīgās figūras veidu (A,B,C,D vai E), bet kolonnas un rindas numurs norāda laukuma rūtiņu, kuru noklāj šīs figūras galvenais kvadrāts. Starp burtu un kolonnas numuru, kā arī starp kolonnas numuru un rindas numuru ir viens tukšumsimbols. Pēc tam faila nākošajā rindā ir dots viens burts (A,B,C,D vai E), kas norāda tās figūras veidu, kuru vēlamies novietot laukumā bez pārklāšanās.



### Izvaddatu raksturojums
> Izvaddatu vienīgajā rindā jāizvada viens vesels skaitlis - vietu skaits laukumā, kur iespējams izvietot figūru.

## Piezīmes
Testpiemēra zīmējums. Derīgās vietas atzīmētas ar krustiņiem:<br>

![pentam3-2](https://user-images.githubusercontent.com/118617121/225158815-b454bca3-53e0-4520-b35c-94cfb4e505dd.gif)




## Paraugdati
#### **Stdin**
<pre><code>5<br>
A 2 5<br>
D 5 7<br>
B 7 6<br>
D 8 1<br>
E 4 6<br>
E</code></pre>
#### **Stdout**
<pre><code>6</code></pre>

### Mans rezultāts
> 11/11 punkti
### Links uz kodu
https://github.com/zieduvija/50_cpp/blob/master/code/pentamino_3.cpp
### Links uz uzdevumu
https://clevercode.lv/task/show/pentam3







</details>

<details>
<summary>Šahs</summary>
<br>

## Šahs

### Definīcija
Uz 8x8 šaha galdiņa viena no lauciņiem novietots tornis. Galdiņa vertikāles un horizontāles tiek apzīmētas tā, kā redzams zīmējumā. Tādējādi katra lauciņa apzīmējums ir burts kopā ar ciparu, piemēram, b6, g1.

![sahs1-1](https://user-images.githubusercontent.com/118617121/224571166-2636287e-55d7-4479-8798-070da2f7fb78.gif)

Uzrakstiet programmu, kas noskaidro, ar kādu mazāko gājienu skaitu dotajā lauciņā novietotais tornis var nokļūt uz katru no 64 šaha galdiņa lauciņiem!

## Šahs 1 - Tornis

### Ievaddatu raksturojums
Ievaddatu vienīgajā rindā dots lauciņš (burts kopā ar ciparu, bez atdalošajām tukšumzīmēm), kurā novietots **tornis**.
### Izvaddatu raksturojums
Jāizvada 8 rindas, pa 8 simboliem katrā rindā. i-tās rindas j-tais simbols norāda, ar kādu mazāko gājienu skaitu tornis no sākuma rūtiņas var nokļūt lauciņā, kas atrodas uz (9-i)-tās horizontāles un j-tās vertikāles. Ja kādā lauciņā nokļūt nav iespējams, tad attiecīgajā pozīcijā jāizvada simbols “\*”.
## Paraugdati
#### **Stdin**
<pre><code>b6</code></pre>
#### **Stdout**
<pre><code>21222222<br>
21222222<br>
10111111<br>
21222222<br>
21222222<br>
21222222<br>
21222222<br>
21222222<br></code></pre>

### Mans rezultāts
> 17/17 punkti
### Links uz kodu
https://github.com/zieduvija/50_cpp/blob/master/code/sahs1.cpp
### Links uz uzdevumu
https://clevercode.lv/task/show/sahs1


## Šahs 2 - Laidnis

### Ievaddatu raksturojums
Ievaddatu vienīgajā rindā dots lauciņš (burts kopā ar ciparu, bez atdalošajām tukšumzīmēm), kurā novietots **laidnis**.
### Izvaddatu raksturojums
Jāizvada 8 rindas, pa 8 simboliem katrā rindā. i-tās rindas j-tais simbols norāda, ar kādu mazāko gājienu skaitu laidnis no sākuma rūtiņas var nokļūt lauciņā, kas atrodas uz (9-i)-tās horizontāles un j-tās vertikāles. Ja kādā lauciņā nokļūt nav iespējams, tad attiecīgajā pozīcijā jāizvada simbols “\*”.

## Paraugdati
#### **Stdin**
<pre><code>b6</code></pre>
#### **Stdout**
<pre><code>*2*1*2*2<br>
1*1*2*2*<br>
*0*2*2*2<br>
1*1*2*2*<br>
*2*1*2*2<br>
2*2*1*2*<br>
*2*2*1*2<br>
2*2*2*1*</code></pre>

### Mans rezultāts
> 17/17 punkti
### Links uz kodu
https://github.com/zieduvija/50_cpp/blob/master/code/sahs2.cpp
### Links uz uzdevumu
https://clevercode.lv/task/show/sahs2

## Šahs 3 - Dāma

### Ievaddatu raksturojums
Ievaddatu vienīgajā rindā dots lauciņš (burts kopā ar ciparu, bez atdalošajām tukšumzīmēm), kurā novietots **dāma**.

### Izvaddatu raksturojums
Jāizvada 8 rindas, pa 8 simboliem katrā rindā. i-tās rindas j-tais simbols norāda, ar kādu mazāko gājienu skaitu dāma no sākuma rūtiņas var nokļūt lauciņā, kas atrodas uz (9-i)-tās horizontāles un j-tās vertikāles. Ja kādā lauciņā nokļūt nav iespējams, tad attiecīgajā pozīcijā jāizvada simbols “\*”.

## Paraugdati
#### **Stdin**
<pre><code>b6</code></pre>
#### **Stdout**
<pre><code>21212222<br>
11122222<br>
10111111<br>
11122222<br>
21212222<br>
21221222<br>
21222122<br>
21222212<br></code></pre>

### Mans rezultāts
> 17/17 punkti
### Links uz kodu
https://github.com/zieduvija/50_cpp/blob/master/code/sahs3.cpp
### Links uz uzdevumu
https://clevercode.lv/task/show/sahs3

## Šahs 4 - Karalis

### Ievaddatu raksturojums
Ievaddatu vienīgajā rindā dots lauciņš (burts kopā ar ciparu, bez atdalošajām tukšumzīmēm), kurā novietots **karalis**.

### Izvaddatu raksturojums
Jāizvada 8 rindas, pa 8 simboliem katrā rindā. i-tās rindas j-tais simbols norāda, ar kādu mazāko gājienu skaitu karalis no sākuma rūtiņas var nokļūt lauciņā, kas atrodas uz (9-i)-tās horizontāles un j-tās vertikāles. Ja kādā lauciņā nokļūt nav iespējams, tad attiecīgajā pozīcijā jāizvada simbols “\*”.


## Paraugdati
#### **Stdin**
<pre><code>b6</code></pre>
#### **Stdout**
<pre><code>22223456<br>
11123456<br>
10123456<br>
11123456<br>
22223456<br>
33333456<br>
44444456<br>
55555556<br></code></pre>

### Mans rezultāts
> 17/17 punkti
### Links uz kodu
https://github.com/zieduvija/50_cpp/blob/master/code/sahs4.cpp
### Links uz uzdevumu
https://clevercode.lv/task/show/sahs4

## Šahs 5 - Zirdziņš

### Ievaddatu raksturojums
Izvaddatu vienīgajā rindā dots lauciņš (burts kopā ar ciparu, bez atdalošajām tukšumzīmēm), kurā novietots **zirdziņš**.

### Izvaddatu raksturojums
Jāizvada 8 rindas, pa 8 simboliem katrā rindā. i-tās rindas j-tais simbols norāda, ar kādu mazāko gājienu skaitu karalis no sākuma rūtiņas var nokļūt lauciņā, kas atrodas uz (9-i)-tās horizontāles un j-tās vertikāles. Ja kādā lauciņā nokļūt nav iespējams, tad attiecīgajā pozīcijā jāizvada simbols “\*”.


## Paraugdati
#### **Stdin**
<pre><code>b6</code></pre>
#### **Stdout**
<pre><code>12143234<br>
23212343<br>
30323234<br>
23212343<br>
12143234<br>
23232343<br>
32323434<br>
43434345<br></code></pre>

### Mans rezultāts
> 17/17 punkti
### Links uz kodu
https://github.com/zieduvija/50_cpp/blob/master/code/sahs5.cpp
### Links uz uzdevumu
https://clevercode.lv/task/show/sahs5

## Šahs 6 - Tornis ar šķērsli

### Ievaddatu raksturojums
Ievaddatu pirmajā rindā dots lauciņš (burts kopā ar ciparu, bez atdalošajām tukšumzīmēm), kurā novietots **tornis**. Otrajā rindā dots **izgrieztais lauciņš**. Zināms, ka abi dotie lauciņi ir atšķirīgi.



### Izvaddatu raksturojums
Jāizvada 8 rindas, pa 8 simboliem katrā rindā. i-tās rindas j-tais simbols norāda, ar kādu mazāko gājienu skaitu **tornis** no sākuma lauciņa var nokļūt lauciņā, kas atrodas uz (9-i)-tās horizontāles un j-tās vertikāles. Ja kādā lauciņā nokļūt nav iespējams, tad attiecīgajā pozīcijā jāizvada simbols “\*”.


## Paraugdati
#### **Stdin**
<pre><code>b6<br>
f6</code></pre>
#### **Stdout**
<pre><code>21222222<br>
21222222<br>
10111*33<br>
21222222<br>
21222222<br>
21222222<br>
21222222<br>
21222222<br></code></pre>

### Mans rezultāts
> 17/17 punkti
### Links uz kodu
https://github.com/zieduvija/50_cpp/blob/master/code/sahs6.cpp
### Links uz uzdevumu
https://clevercode.lv/task/show/sahs6


## Šahs 7 - Laidnis ar šķērsli

### Ievaddatu raksturojums
Ievaddatu pirmajā rindā dots lauciņš (burts kopā ar ciparu, bez atdalošajām tukšumzīmēm), kurā novietots **laidnis**. Otrajā rindā dots **izgrieztais lauciņš**. Zināms, ka abi dotie lauciņi ir atšķirīgi.



### Izvaddatu raksturojums
Jāizvada 8 rindas, pa 8 simboliem katrā rindā. i-tās rindas j-tais simbols norāda, ar kādu mazāko gājienu skaitu **laidnis** no sākuma lauciņa var nokļūt lauciņā, kas atrodas uz (9-i)-tās horizontāles un j-tās vertikāles. Ja kādā lauciņā nokļūt nav iespējams, tad attiecīgajā pozīcijā jāizvada simbols “\*”.


## Paraugdati
#### **Stdin**
<pre><code>b6<br>
f6</code></pre>
#### **Stdout**
<pre><code>*2*3*2*2<br>
2*2***2*<br>
*2*2*2*1<br>
2*2*2*1*<br>
*2*2*1*2<br>
1*2*1*2*<br>
*1*1*2*2<br>
2*0*2*2*<br></code></pre>

### Mans rezultāts
> 17/17 punkti
### Links uz kodu
https://github.com/zieduvija/50_cpp/blob/master/code/sahs7.cpp
### Links uz uzdevumu
https://clevercode.lv/task/show/sahs7



## Šahs 8 - Dāma ar šķērsli

### Ievaddatu raksturojums
Ievaddatu pirmajā rindā dots lauciņš (burts kopā ar ciparu, bez atdalošajām tukšumzīmēm), kurā novietota **dāma**. Otrajā rindā dots **izgrieztais lauciņš**. Zināms, ka abi dotie lauciņi ir atšķirīgi.



### Izvaddatu raksturojums
Jāizvada 8 rindas, pa 8 simboliem katrā rindā. i-tās rindas j-tais simbols norāda, ar kādu mazāko gājienu skaitu **dāma** no sākuma lauciņa var nokļūt lauciņā, kas atrodas uz (9-i)-tās horizontāles un j-tās vertikāles. Ja kādā lauciņā nokļūt nav iespējams, tad attiecīgajā pozīcijā jāizvada simbols “\*”.


## Paraugdati
#### **Stdin**
<pre><code>b6<br>
f6</code></pre>
#### **Stdout**
<pre><code>21212222<br>
11122222<br>
10111*22<br>
11122222<br>
21212222<br>
21221222<br>
21222122<br>
21222212<br></code></pre>

### Mans rezultāts
> 17/17 punkti
### Links uz kodu
https://github.com/zieduvija/50_cpp/blob/master/code/sahs8.cpp
### Links uz uzdevumu
https://clevercode.lv/task/show/sahs8


## Šahs 9 - Karalis ar šķērsli

### Ievaddatu raksturojums
Ievaddatu pirmajā rindā dots lauciņš (burts kopā ar ciparu, bez atdalošajām tukšumzīmēm), kurā novietots **karalis**. Otrajā rindā dots **izgrieztais lauciņš**. Zināms, ka abi dotie lauciņi ir atšķirīgi.




### Izvaddatu raksturojums
Jāizvada 8 rindas, pa 8 simboliem katrā rindā. i-tās rindas j-tais simbols norāda, ar kādu mazāko gājienu skaitu **karalis** no sākuma lauciņa var nokļūt lauciņā, kas atrodas uz (9-i)-tās horizontāles un j-tās vertikāles. Ja kādā lauciņā nokļūt nav iespējams, tad attiecīgajā pozīcijā jāizvada simbols “\*”.


## Paraugdati
#### **Stdin**
<pre><code>b6<br>
f6</code></pre>
#### **Stdout**
<pre><code>22223456<br>
11123456<br>
10123*56<br>
11123456<br>
22223456<br>
33333456<br>
44444456<br>
55555556<br></code></pre>

### Mans rezultāts
> 17/17 punkti
### Links uz kodu
https://github.com/zieduvija/50_cpp/blob/master/code/sahs9.cpp
### Links uz uzdevumu
https://clevercode.lv/task/show/sahs9
</details>

<details>
<summary>Leetcode</summary>
  
## Uzdevumi pildīti iekš leetcode

### Uzdevums: Two Sum 

Grūtība: Easy 

46.7K 

1.5K 

Companies 

Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.You may assume that each input would have exactly one solution, and you may not use the same element twice. 

You can return the answer in any order. 

 links: https://leetcode.com/problems/two-sum/description/ 

Atbildes kods:  

class Solution { 

public: 

    vector<int> twoSum(vector<int>& nums, int target) { 

        unordered_map<int, int> skatili; 

        for(int i=0;i<nums.size();i++){ 

            auto it=skatili.find(target-nums[i]); 

 

            if(it!=skatili.end()) return { 

                i, it->second 

                }; 

            skatili.insert({nums[i], i}); 

        } 

        return {-1, -1}; 

    } 

}; 

 

 

Rezultāts: Accepted, Runtime: 4 ms 
  
  
  
### Uzdevums: isPalindrome 

Pārbaudīt vai int mainīgais ir palindroms. 

Links: https://leetcode.com/problems/palindrome-number/ 

class Solution { 

public: 

    bool isPalindrome(int x) { 

        ostringstream converter; 

        converter << x; 

        string virkne = converter.str(); 

         

        int i = 0, j = virkne.size() - 1; 

        while (i < j) { 

            if (virkne[j] != virkne[i]) 

                return false; 

            i++; j--; 

        } 

        return true; 

    } 

}; 

 

Akceptēts 
  
  
  
### Uzdevums: Longest common prefix 

 

Atrast virkņu masīva garāko priedēkli ar kuru sākās visi vārdi. 

 

Links: https://leetcode.com/problems/longest-common-prefix/ 

 

class Solution { 

public: 

    string longestCommonPrefix(vector<string>& strs) { 

        sort(strs.begin(),strs.end()); 

        int a=strs.size(); 

        string n = strs[0], m = strs[a-1], atb = ""; 

        for(int i=0;i<n.size();i++){ 

            if(n[i]==m[i]) 

            atb+=n[i]; 

            else break; 

        } 

        return atb; 

         

    } 

}; 

 

Akceptēts, 0ms runtime 

 

 
 

### Uzdevums: Valid Parenthesis 

 

Parbaduīt vai virknē visas atvertās iekavas ir aizvērtas. 

 

Links: https://leetcode.com/problems/valid-parentheses/ 

 

#include <stack> 

#include <string> 

 

class Solution { 

public: 

    bool isValid(string s) { 

        std::stack<char> st; 

        for (char ch : s) { 

            if (ch == '(' || ch == '{' || ch == '[') { 

                st.push(ch); 

            } else { 

                if (!st.empty()) { 

                    char top = st.top(); 

                    if ((ch == ')' && top == '(') || 

                        (ch == '}' && top == '{') || 

                        (ch == ']' && top == '[')) { 

                        st.pop(); 

                    } else { 

                        return false; 

                    } 

                } else { 

                    return false; 

                } 

            } 

        } 

        return st.empty(); 

    } 

}; 

 

Akceptēts, ātrs atrisinājums bet izmanto daudz atmiņas. 

 

 
 

 

### Uzdevums: Merge two sorted lists 

 

Apvienot 2 sakārtotus sarakstus ar skaitļiem vienā. 

 

Links: https://leetcode.com/problems/merge-two-sorted-lists 

 

/** 

 * Definition for singly-linked list. 

 * struct ListNode { 

 *     int val; 

 *     ListNode *next; 

 *     ListNode() : val(0), next(nullptr) {} 

 *     ListNode(int x) : val(x), next(nullptr) {} 

 *     ListNode(int x, ListNode *next) : val(x), next(next) {} 

 * }; 

 */ 

class Solution { 

public: 

    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { 

        ListNode* x = new ListNode(0);  

        ListNode* current = x; 

         

        while (l1 != nullptr && l2 != nullptr) { 

            if (l1->val <= l2->val) { 

                current->next = l1; 

                l1 = l1->next; 

            } else { 

                current->next = l2; 

                l2 = l2->next; 

            } 

            current = current->next; 

        } 

         

        if (l1 != nullptr) { 

            current->next = l1; 

        } else if (l2 != nullptr) { 

            current->next = l2; 

        } 

         

        ListNode* saplSaraksts = x->next;  

        delete x;  

         

        return saplSaraksts; 

    } 

}; 

 

 

Akceptēts 

 
 

### Uzdevums: Remove duplicates from Sorted Array 

 

Izņemt duplikātu skaitļus no int saraksta. 

 

Links: https://leetcode.com/problems/remove-duplicates-from-sorted-array/ 

 

class Solution { 

public: 

    int removeDuplicates(vector<int>& nums) { 

    int sk=1; 

    for(int i=1; i<nums.size(); i++)         

        if(nums[i]!=nums[i-1]) nums[sk++] = nums[i];      

    return sk;  

    } 

}; 

 

Akceptēts, bet lēnāks par 60% no pārējiem iesniegtajiem risinājumiem. 

 

### Uzdevums: Remove element 

 

No vector masīva izņemt norādīto skaitli. 

Links: https://leetcode.com/problems/remove-element/ 

 

class Solution { 

public: 

    int removeElement(vector<int>& nums, int val) { 

        int j=0; 

        for(int i=0;i<nums.size();i++){ 

            if(nums[i]!=val){ 

                nums[j++]=nums[i]; 

            } 

        } 

        return j;         

    } 

}; 

 

Akceptēts, ļoti vienkāršs risinājums. 

 

 
 

### Uzdevums: Find the index of the first occurance in a string 

Atrast virknē atrodošos vārdu un atgriezt indeksu kurā tas sākas. 

Links: https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/ 

 

class Solution { 

public: 

    int strStr(string haystack, string needle) { 

        int m = haystack.size(); 

        int n = needle.size(); 

         

        if (n == 0) { 

            return 0; 

        } 

         

        for (int i = 0; i <= m - n; i++) { 

            bool atrasts = true; 

             

            for (int j = 0; j < n; j++) { 

                if (haystack[i + j] != needle[j]) { 

                    atrasts = false; 

                    break; 

                } 

            } 

             

            if (atrasts) { 

                return i;  

            } 

        } 

         

        return -1; 

    } 

}; 

 

Akceptēts 

 

### Uzdevums: Search Insert Position 

Atgriezt kurā indeksā ir skaitlis masīvā un kurā tas būtu ja to ievietotu dotajā masīvā. 

Links: https://leetcode.com/problems/search-insert-position/ 

 

class Solution { 

public: 

    int searchInsert(vector<int>& nums, int target) { 

        int kreisi = 0; 

        int labi = nums.size() - 1; 

 

        while (kreisi <= labi) { 

            int vidus = kreisi + (labi - kreisi) / 2; 

            if (nums[vidus] == target) return vidus; 

             else if (nums[vidus] < target) kreisi = vidus + 1; 

             else labi = vidus - 1; 

             

        } 

 

        return kreisi; 

    } 

}; 

Akceptēts 

### Uzdevums: Length of last word 

 

No virknes atgriezt tās pēdējā vārda garumu. 

 

Links: https://leetcode.com/problems/length-of-last-word/ 

 

class Solution { 

public: 

    int lengthOfLastWord(string s) { 

        int a = 0, garums = 0; 

        for(int i=s.length()-1;i>=0;i--){ 

            if(s[i] != ' '){ 

                a = i; 

                break; 

                } 

        } 

        for(int i=a;i>=0;i--){ 

            if(s[i]==' ') break; 

            else garums++; 

        } 

        return garums; 

    } 

}; 

 

Akceptēts, bet nav ātrākais risinājums. 

 

### Uzdevums: Plus one 

 

Dots masīvas ar skaitļiem, piem [1,2,3] un tam japieskaita 1, uzskatot masīvu kā pilnu skaitli. [1,2,3] + 1 = [1,2,4] 

Links: https://leetcode.com/problems/plus-one/ 

 

class Solution { 

public: 

    vector<int> plusOne(vector<int>& digits) { 

        int n = digits.size(); 

        int parn = 1; 

 

        for (int i = n - 1; i >= 0; i--) { 

            int sum = digits[i] + parn; 

            digits[i] = sum % 10; 

            parn = sum / 10; 

        } 

 

        if (parn != 0) { 

            digits.insert(digits.begin(), parn); 

        } 

 

        return digits; 

    } 

}; 

Akceptēts
 
 

### Uzdevums: Add binary 

 

Doti divi bināri skaitļi virknēs, tos vajag saskaitīt un atgriezt. 

 

class Solution { 

public: 

    string addBinary(string a, string b) { 

        int parn = 0; 

        string res = ""; 

 

        int i = a.size() - 1; 

        int j = b.size() - 1; 

 

        while (i >= 0 || j >= 0 || parn != 0) { 

            int sum = parn; 

            if (i >= 0) { 

                sum += a[i--] - '0'; 

            } 

            if (j >= 0) { 

                sum += b[j--] - '0'; 

            } 

 

            res = to_string(sum % 2) + res; 

            parn = sum / 2; 

        } 

 

        return res; 

    } 

}; 

 

Akceptēts 

 

 
 

### Uzdevums: Sqrt(x) 

Dots pozitīvs skaitlis vajag atgriezt tuvāko int mainīgo tā kvadrātsaknei. 

 

Links: https://leetcode.com/problems/sqrtx/ 

 

class Solution { 

public: 

    int mySqrt(int x) { 

        if (x == 0) 

            return x; 

        int kreisi = 1, labi = x, res = 0; 

 

        while (kreisi <= labi) { 

            int vidus = kreisi + (labi - kreisi) / 2; 

            if (vidus <= x / vidus) { 

                res = vidus; 

                kreisi = vidus + 1; 

            } else labi = vidus - 1;     

        } 

        return res; 

    } 

}; 

 

Akceptēts 

 

### Uzdevums: Climbing Stairs 

 

Ir dotas kāpnes ar n skaitu pakāpieniem, tu vari vienā gājienā uzkāpt 1 vai 2 pakāpienus augstāk. Vajag atgriezt cik veidos vari uzkāpt pa kāpnēm, lai sasniegtu augšu. 

Links: https://leetcode.com/problems/climbing-stairs/ 

 

class Solution { 

public: 

    int climbStairs(int n) { 

        if (n <= 2)  

            return n;    

        int pag1 = 1, pag2 = 2; 

 

        for (int i = 3; i <= n; i++) { 

            int pasreiz = pag1 + pag2; 

            pag1 = pag2; 

            pag2 = pasreiz; 

        } 

 

        return pag2; 

    } 

}; 

 

Akceptēts, ātrāks risinājums par 100% no pārējiem iesniegtajiem. 

 
 

### Uzdevums: Remove duplicates from sorted list 

 

No sakārtota saraksta izņemt duplikātā vērtības un jāatgriež sarakts. 

 

Links: https://leetcode.com/problems/remove-duplicates-from-sorted-list/ 

 

class Solution { 

public: 

    ListNode* deleteDuplicates(ListNode* head) { 

        ListNode* pasreiz = head; 

 

        while (pasreiz != nullptr && pasreiz->next != nullptr) { 

            if (pasreiz->val == pasreiz->next->val) { 

                ListNode* duplikats = pasreiz->next; 

                pasreiz->next = pasreiz->next->next; 

                delete duplikats; 

            } else { 

                pasreiz = pasreiz->next; 

            } 

        } 

 

        return head; 

    } 

}; 

 

Akceptēts 
  
  
  
  
  
  
  
  
  
  
  
  
### Uzdevums Longest substring without repeating characters 

 

Atrast garāko virkni ar burtiem kuri neatkārtojas un atgriezt šīs virknes garumu. 

 

Links: https://leetcode.com/problems/remove-duplicates-from-sorted-list/ 

 

class Solution { 

public: 

    int lengthOfLongestSubstring(string s) { 

        unordered_map<char, int> m; 

        int maxGarums = 0; 

        int i = 0; 

         

        for (int j = 0; j < s.length(); j++) { 

            if (m.find(s[j]) != m.end()) { 

                i = max(i, m[s[j]] + 1); 

            } 

            m[s[j]] = j; 

            maxGarums = max(maxGarums, j - i + 1); 

        } 

         

        return maxGarums; 

    } 

}; 

 

Akceptēts 

 

### Uzdevums Longest palindromic substring 

 

Atrast garāko palindromu dotajā virknē un to atgriezt. 

 

Links: https://leetcode.com/problems/longest-palindromic-substring/ 

 

 

class Solution { 

private: 

    int parbaude(string &s, int kreisi, int labi) { 

        while (kreisi >= 0 && labi < s.length() && s[kreisi] == s[labi]) { 

            kreisi--; 

            labi++; 

        } 

        return labi - kreisi - 1; 

    } 

 
 

public: 

    string longestPalindrome(string s) { 

        int n = s.size(); 

        int saukms = 0; 

        int maxGarums = 0; 

 
 

        for (int i = 0; i < n; i++) { 

            int gar1 = parbaude(s, i, i); 

            int gar2 = parbaude(s, i, i + 1); 

 
 

            int garums = max(gar1, gar2); 

            if (garums > maxGarums) { 

                maxGarums = garums; 

                saukms = i - (garums - 1) / 2; 

            } 

        } 

 
 

        return s.substr(saukms, maxGarums); 

    } 

}; 

 

Akceptēts 

 

### Uzdevums Zigzag conversion 

 

Izveidot kodu kurs parvers virkni par zigzagu nemot vērā doto rindu skaitu, piem. Virkne " PAYPALISHIRING " ar rindu skaitu 3 =  

 

P   A   H   N 
A P L S I I G 
Y   I   R 

 

Un to lasot atgriezt pa rindai virkni, šajā gadījumā atgriezt vajag:  

"PAHNAPLSIIGYIR" 

 

Links: https://leetcode.com/problems/zigzag-conversion/ 

 

class Solution { 

public: 

    string convert(string s, int numRows) { 

        if (numRows <= 1) { 

            return s; 

        } 

         

        vector<string> rindas(numRows); 

        int rinda = 0; 

        int virziens = 1; 

         

        for (char c : s) { 

            rindas[rinda] += c; 

             

            if (rinda == 0) { 

                virziens = 1; 

            } else if (rinda == numRows - 1) { 

                virziens = -1; 

            } 

             

            rinda += virziens; 

        } 

         

        string res; 

        for (string& rinda : rindas) { 

            res += rinda; 

        } 

         

        return res; 

    } 

}; 

 

Akceptēts 

 

### Uzdevums Reverse Integer 

 

Apgriezt skaitli otrādāk un atgriezt to. 

 

Links: https://leetcode.com/problems/reverse-integer/ 

 

class Solution { 

public: 

    int reverse(int x) { 

        long apgriezts = 0; 

         

        while (x != 0) { 

            apgriezts = apgriezts * 10 + x % 10; 

            x = x / 10; 

        } 

         

        if (apgriezts > INT_MAX || apgriezts < INT_MIN) { 

            return 0; 

        } 

         

        return static_cast<int>(apgriezts); 

    } 

}; 

 

Akceptēts, patērē mazāk atmiņas par 94% no pārējo iesniegtajiem risinājumiem. 

 
 

### Uzdevums Alternating digit sum 

 

Dots skaitlis n, katru ciparu skaitlī vajag saskaitīt mainot zīmi katram otrajam ciparam. Piem. N = 321, res = 3 + (-2) + 1 

 

Links: https://leetcode.com/problems/alternating-digit-sum/ 

 

class Solution { 

public: 

    int alternateDigitSum(int n) { 

        vector<int> cipari; 

        while (n > 0) { 

            cipari.push_back(n % 10); 

            n /= 10; 

        } 

        reverse(cipari.begin(), cipari.end()); 

         

        int sum1 = 0, sum2 = 0; 

        for (int i = 0; i < cipari.size(); i++) { 

            if (i % 2 == 0) { 

                sum1 += cipari[i]; 

            } else { 

                sum2 += cipari[i]; 

            } 

        } 

         

        return sum1 - sum2; 

    } 

}; 

 

Akceptēts 

 

### Uzdevums Generate Fibonnaci sequence 

 

Ģenerēt n, fibonačī skaitļus. 

 

Links: https://leetcode.com/problems/generate-fibonacci-sequence/description/ 

 

function* fibGenerator() { 

    let ieprieks = 0; 

    let pasreiz = 1; 

 
 

    yield ieprieks; 

     

    while (true) { 

        yield pasreiz; 

        [ieprieks, pasreiz] = [pasreiz, ieprieks + pasreiz]; 

    } 

} 

 

Akceptēts 

 

 
 

### Uzdevums Sort the people 

 

Ievietot cilvēku vārdus virknē ņemot vērā to augumus. 

 

Links: https://leetcode.com/problems/sort-the-people/ 

 

class Solution { 

public: std::vector<std::string> sortPeople(std::vector<std::string>& names, std::vector<int>& heights) { 

    std::map<int, std::string> sakartotsM; 

     

    for (size_t i = 0; i < names.size(); i++) { 

        sakartotsM[heights[i]] = names[i]; 

    } 

     

    std::vector<std::string> sakartotsV; 

     

    for (auto it = sakartotsM.rbegin(); it != sakartotsM.rend(); ++it) { 

        sakartotsV.push_back(it->second); 

    } 

     

    return sakartotsV; 

} 

 
 

}; 

 

Akceptēts 

 

### Uzdevums Counting words with a given prefix 

 

Masīvā ir doti vārdi, vajag atrast vārdus kuri satur doto priedēkli un atgriezt skaitu cik vardos ir šis priedēklis. 

 

Links: https://leetcode.com/problems/counting-words-with-a-given-prefix/ 

 

class Solution { 

public: 

    int prefixCount(std::vector<std::string>& words, std::string pref) { 

        int skaits = 0; 

        int priedGarums = pref.size(); 

         

        for (const std::string& word : words) { 

            if (word.substr(0, priedGarums) == pref) { 

                skaits++; 

            } 

        } 

         

        return skaits; 

    } 

}; 

 

Akceptēts 

 
### Uzdevums Strong password checker II 

 

Pārbaudīt vai dotā virkne satur: 

Vismaz 8 rakstu zīmes 

Vismaz vienu mazo burtu 

Vismaz vienu lielo burtu 

Vismaz vienu skaitli 

Vismaz vienu simbolu 

Tas nesatur 2 vienādas rakstzīmes blakus esošajās pozīcijās (t.i., "aab" pārkāpj šo nosacījumu, bet "aba" ne). 

Ja sakrīt kritērijiem atgriezt true, ja nē tad false. 

 

Links: https://leetcode.com/problems/strong-password-checker-ii/ 

 

class Solution { 

public: 

    bool strongPasswordCheckerII(std::string p) { 

        if (p.size() < 8) { 

            return false; 

        } 

         

        bool mazais = false, lielais = false, skaitlis = false, simbols = false; 

         

        for (char c : p) { 

            if (c >= 'a' && c <= 'z') { 

                mazais = true; 

            } else if (c >= 'A' && c <= 'Z') { 

                lielais = true; 

            } else if (isdigit(c)) { 

                skaitlis = true; 

            } else { 

                simbols = true; 

            } 

        } 

         

        for (int i = 0; i + 1 < p.size(); i++) { 

            if (p[i] == p[i + 1]) { 

                return false; 

            } 

        } 

 
 

        if (mazais && lielais && skaitlis && simbols) { 

            return true; 

        } 

         

        return false; 

    } 

}; 

 

Akceptēts, ātraks par 100% no iesniegtajiem risinājumiem. 

 
 

### Uzdevums Check if numbers are ascending in a sentence 

 

Dotā virknē pārbaudīt vai iesaistītie skaitļi ir augošā secībā. 

 

Links: https://leetcode.com/problems/check-if-numbers-are-ascending-in-a-sentence/ 

 

class Solution { 

public: 

    bool areNumbersAscending(std::string s) { 

        std::vector<int> skaitli; 

         

        int i = 0; 

        int n = s.size(); 

         

        while (i < n) { 

            if (isdigit(s[i])) { 

                std::string temp; 

                 

                while (i < n && isdigit(s[i])) { 

                    temp += s[i]; 

                    i++; 

                } 

                 

                skaitli.push_back(std::stoi(temp)); 

            } 

             

            i++; 

        } 

         

        for (int i = 0; i < skaitli.size() - 1; i++) { 

            if (skaitli[i] >= skaitli[i + 1]) { 

                return false; 

            } 

        } 

         

        return true; 

    } 

}; 

 

Akceptēts, ātrāks par 100% no iesniegtajiem risinājumiem. 
  
  
  
 </details>

